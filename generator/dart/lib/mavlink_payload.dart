/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the Dart mavlink generator tool.
 * It should not be modified by hand.
 */

import 'dart:typed_data';

/// Wrapper around ByteData to represent a MAVLink message payload
class MAVLinkPayload {
  static const int maxPayloadSize = 255;

  late final ByteData _byteData;

  int _filledLength = 0;

  int _getterIndex = 0;

  // This has to be larger than the received payloadSize since MAVLINK V2 will truncate the payloads to the last non-zero value
  MAVLinkPayload() : this.ofSpecificLength(maxPayloadSize);

  MAVLinkPayload.ofSpecificLength(int length) {
    if (length > 255 || length < 0) {
      throw Exception("Cannot create payload of illegal length: $length");
    }
    _byteData = ByteData(length);
  }

  int get length => _byteData.lengthInBytes;

  int get filledLength => _filledLength;

  void resetIndex() => _getterIndex = 0;

  int _updateGetterIndex(int numBytes) {
    int currentIndex = _getterIndex;
    _getterIndex += numBytes;
    return currentIndex;
  }

  int _updateStateOnPut(int numBytes) {
    int currentIndex = _getterIndex;
    _filledLength += numBytes;
    _getterIndex += numBytes;
    return currentIndex;
  }

  int getInt8() => _byteData.getInt8(_getterIndex++);

  int getUint8() => _byteData.getUint8(_getterIndex++);

  int getInt16() => _byteData.getInt16(_updateGetterIndex(2), Endian.little);

  int getUint16() => _byteData.getUint16(_updateGetterIndex(2), Endian.little);

  int getInt32() => _byteData.getInt32(_updateGetterIndex(4), Endian.little);

  int getUint32() => _byteData.getUint32(_updateGetterIndex(4), Endian.little);

  int getInt64() => _byteData.getInt64(_updateGetterIndex(8), Endian.little);

  // TODO Possible bug because Dart has only 64 bit signed int type
  int getUint64() => _byteData.getUint64(_updateGetterIndex(8), Endian.little);

  double getFloat() =>
      _byteData.getFloat32(_updateGetterIndex(4), Endian.little);

  double getDouble() =>
      _byteData.getFloat64(_updateGetterIndex(8), Endian.little);

  void putInt8(int data) => _byteData.setInt8(_updateStateOnPut(1), data);

  void putUint8(int data) => _byteData.setUint8(_updateStateOnPut(1), data);

  void putInt16(int data) =>
      _byteData.setInt16(_updateStateOnPut(2), data, Endian.little);

  void putUint16(int data) =>
      _byteData.setUint16(_updateStateOnPut(2), data, Endian.little);

  void putInt32(int data) =>
      _byteData.setInt32(_updateStateOnPut(4), data, Endian.little);

  void putUint32(int data) =>
      _byteData.setUint32(_updateStateOnPut(4), data, Endian.little);

  void putInt64(int data) =>
      _byteData.setInt64(_updateStateOnPut(8), data, Endian.little);

  // TODO Possible bug because Dart has only 64 bit signed int type
  void putUint64(int data) =>
      _byteData.setUint64(_updateStateOnPut(8), data, Endian.little);

  void putFloat(double data) =>
      _byteData.setFloat32(_updateStateOnPut(4), data, Endian.little);

  void putDouble(double data) =>
      _byteData.setFloat64(_updateStateOnPut(8), data, Endian.little);
}
