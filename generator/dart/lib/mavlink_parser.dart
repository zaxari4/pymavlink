/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the Dart mavlink generator tool.
 * It should not be modified by hand.
 */

// ignore_for_file: constant_identifier_names

import 'mavlink_packet.dart';
import 'mavlink_stats.dart';

/// States from the parsing state machine
enum MAV_states {
  MAVLINK_PARSE_STATE_UNINIT,
  MAVLINK_PARSE_STATE_IDLE,
  MAVLINK_PARSE_STATE_GOT_STX,
  MAVLINK_PARSE_STATE_GOT_LENGTH,
  MAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS, // MAVLink 2
  MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS, // MAVLink 2
  MAVLINK_PARSE_STATE_GOT_SEQ,
  MAVLINK_PARSE_STATE_GOT_SYSID,
  MAVLINK_PARSE_STATE_GOT_COMPID,
  MAVLINK_PARSE_STATE_GOT_MSGID1,
  MAVLINK_PARSE_STATE_GOT_MSGID2, // MAVLink 2
  MAVLINK_PARSE_STATE_GOT_MSGID3, // MAVLink 2
  MAVLINK_PARSE_STATE_GOT_CRC1,
  MAVLINK_PARSE_STATE_GOT_CRC2, // MAVLink 2
  MAVLINK_PARSE_STATE_GOT_PAYLOAD,
  MAVLINK_PARSE_STATE_GOT_SIGNATURE, // MAVLink 2
}

/// MAVLink parser that parses MAVLinkPackets from a byte stream one byte at a time.
/// After creating an instance of this class, simply use the mavlink_parse_char method to parse a byte stream.
class Parser {
  static const String TAG = 'Parser';
  static const bool V = false;

  static void logv(String tag, String msg) {
    if (V) print('$tag: $msg');
  }

  var _state = MAV_states.MAVLINK_PARSE_STATE_UNINIT;

  MAVLinkStats stats;
  late MAVLinkPacket m;

  bool isMavlink2 = false;

  Parser() : this.withStats(false);

  Parser.withStats(bool ignoreRadioPacketStats)
      : stats = MAVLinkStats(ignoreRadioPacketStats);

  /// This is a convenience function which handles the complete MAVLink
  /// parsing. the function will parse one byte at a time and return the
  /// complete packet once it could be successfully decoded. Checksum and other
  /// failures will be silently ignored.
  ///
  /// @param c The char to parse
  /// @return the complete @{link MAVLinkPacket} if successfully decoded, else null
  ///
  MAVLinkPacket? parseChar(int c) {
    // force to 8 bits
    c &= 0xFF;

    switch (_state) {
      case MAV_states.MAVLINK_PARSE_STATE_UNINIT:
      case MAV_states.MAVLINK_PARSE_STATE_IDLE:
        // MAVLink 1 and 2
        if (c == MAVLinkPacket.MAVLINK_STX_MAVLINK2) {
          _state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX;
          if (!isMavlink2) {
            isMavlink2 = true;
            logv(TAG, "Turning mavlink2 ON");
          }
        } else if (c == MAVLinkPacket.MAVLINK_STX_MAVLINK1) {
          _state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX;
          if (isMavlink2) {
            isMavlink2 = false;
            logv(TAG, "Turning mavlink2 OFF");
          }
        }
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_STX:
        // MAVLink 1 and 2
        m = MAVLinkPacket.ofSpecificLengthAndVersion(c, isMavlink2);
        if (isMavlink2) {
          _state = MAV_states.MAVLINK_PARSE_STATE_GOT_LENGTH;
        } else {
          _state = MAV_states.MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS;
        }
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_LENGTH:
        // MAVLink 1 and 2
        m.incompatFlags = c;
        if (c != 0 && c != 1) {
          // message includes an incompatible feature flag
          _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
          break;
        }
        _state = MAV_states.MAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS;
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS:
        // MAVLink 2 only
        m.compatFlags = c;
        _state = MAV_states.MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS;
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS:
        m.seq = c;
        _state = MAV_states.MAVLINK_PARSE_STATE_GOT_SEQ;
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_SEQ:
        // back to MAVLink 1 and 2
        m.sysid = c;
        _state = MAV_states.MAVLINK_PARSE_STATE_GOT_SYSID;
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_SYSID:
        // MAVLink 1 and 2
        m.compid = c;
        _state = MAV_states.MAVLINK_PARSE_STATE_GOT_COMPID;
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_COMPID:
        // MAVLink 1 and 2
        m.msgid = c;
        if (isMavlink2) {
          _state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID1;
        } else if (m.len > 0) {
          _state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID3;
        } else {
          _state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;
        }
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID1:
        // MAVLink 2 only
        m.msgid |= c << 8;
        _state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID2;
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID2:
        // MAVLink 2 only
        m.msgid |= c << 16;
        if (m.len > 0) {
          _state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID3;
        } else {
          _state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;
        }
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID3:
        // back to MAVLink 1 and 2
        m.payload.putInt8(c & 0xFF);
        //m.payload.add((byte) c);
        if (m.payloadIsFilled()) {
          _state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;
        }
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD:
        bool crcGen = m.generateCRC(m.payload.filledLength); // TODO length
        // Check first checksum byte and verify the CRC was successfully generated (msg extra exists)
        if (c != m.crc.getLSB() || !crcGen) {
          _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
          stats.crcError();
        } else {
          _state = MAV_states.MAVLINK_PARSE_STATE_GOT_CRC1;
        }
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_CRC1:
        // Check second checksum byte
        if (c != m.crc.getMSB()) {
          _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
          stats.crcError();
        } else {
          // crc is good
          stats.newPacket(m);

          if (!isMavlink2 || (m.incompatFlags != 0x01)) {
            // If no signature, then return the message.
            _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
            return m;
          } else {
            // TODO: MAVLink 2 - signed
            _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
            stats.crcError();
          }
        }
        break;

      case MAV_states.MAVLINK_PARSE_STATE_GOT_CRC2:
        // TODO: implement signature parsing and validation
        _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
        stats.crcError();
        break;
      case MAV_states.MAVLINK_PARSE_STATE_GOT_SIGNATURE:
        // Was not implemented in Java version, added just for passing the Dart's lint
        break;
    } // switch
    return null;
  }
}
