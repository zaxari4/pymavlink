/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the Dart mavlink generator tool.
 * It should not be modified by hand.
 */

import 'mavlink_packet.dart';
import 'common/msg_radio_status.dart';

/// Stat structure for every system id
class SystemStat {
  int lostPacketCount = 0; // the lost count for this source
  int receivedPacketCount = 0;

  /// stats are null for a component id
  /// until a packet has been received from a system
  Map<int, ComponentStat> componentStats = {};

  SystemStat() {
    resetStats();
  }

  int newPacket(MAVLinkPacket packet) {
    int newLostPackets = 0;
    // only allocate stats for systems that exist on the network
    componentStats[packet.compid] ??= ComponentStat();
    newLostPackets = componentStats[packet.compid]!.newPacket(packet);
    lostPacketCount += newLostPackets;
    receivedPacketCount++;
    return newLostPackets;
  }

  void resetStats() {
    lostPacketCount = 0;
    receivedPacketCount = 0;
    componentStats = {};
  }
}

/// stat structure for every system id
class ComponentStat {
  int lastPacketSeq = -1;
  int lostPacketCount = 0; // the lost count for this source
  int receivedPacketCount = 0;

  ComponentStat() {
    resetStats();
  }

  int newPacket(MAVLinkPacket packet) {
    int newLostPackets = 0;
    if (hasLostPackets(packet)) {
      newLostPackets = _updateLostPacketCount(packet);
    }
    lastPacketSeq = packet.seq;
    advanceLastPacketSequence(packet.seq);
    receivedPacketCount++;
    return newLostPackets;
  }

  void resetStats() {
    lastPacketSeq = -1;
    lostPacketCount = 0;
    receivedPacketCount = 0;
  }

  int _updateLostPacketCount(MAVLinkPacket packet) {
    int lostPackets;
    if (packet.seq - lastPacketSeq < 0) {
      lostPackets = (packet.seq - lastPacketSeq) + 255;
    } else {
      lostPackets = (packet.seq - lastPacketSeq);
    }
    lostPacketCount += lostPackets;
    return lostPackets;
  }

  void advanceLastPacketSequence(int lastSeq) {
    // wrap from 255 to 0 if necessary
    lastPacketSeq = (lastSeq + 1) & 0xFF;
  }

  bool hasLostPackets(MAVLinkPacket packet) {
    return lastPacketSeq >= 0 && packet.seq != lastPacketSeq;
  }
}

/// Storage for MAVLink Packet and Error statistics
class MAVLinkStats {
  static const int maxSysIds = 256;

  /// total recieved packet count for all sources
  int receivedPacketCount = 0;

  /// total lost packet count for all sources
  int lostPacketCount = 0;

  int crcErrorCount = 0;

  bool ignoreRadioPackets = false;

  /// stats are null for a system id until a packet has been received from a system
  Map<int, SystemStat> systemStats = {}; // stats for each system that is known

  MAVLinkStats(this.ignoreRadioPackets);

  /// Check the new received packet to see if has lost someone between
  /// this and the last packet
  ///
  /// @param packet Packet that should be checked
  ///
  void newPacket(MAVLinkPacket packet) {
    if (ignoreRadioPackets &&
        packet.msgid == MsgRadioStatus.MAVLINK_MSG_ID_RADIO_STATUS) {
      return;
    }

    // only allocate stats for systems that exist on the network
    systemStats[packet.sysid] ??= SystemStat();
    lostPacketCount += systemStats[packet.sysid]!.newPacket(packet);
    receivedPacketCount++;
  }

  /// Called when a CRC error happens on the parser
  void crcError() => crcErrorCount++;

  void resetStats() {
    crcErrorCount = 0;
    lostPacketCount = 0;
    receivedPacketCount = 0;
    systemStats = {};
  }
}
